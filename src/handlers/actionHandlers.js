/**
 * X·ª≠ l√Ω c√°c action t·ª´ n√∫t b·∫•m callback
 */

const { Markup } = require('telegraf');
const { formatMessage, EMOJI, OPTIONS } = require('../utils/messageFormatter');
const {
	getUserState,
	updateUserState,
	resetUserState,
} = require('../utils/userState');
const {
	processSrtFile,
	processLocalVideo,
	processSubtitle,
} = require('../services/subtitleProcessor');
const {
	checkUserPermission,
	incrementUserCommand,
	isAdmin,
} = require('../utils/userPermission');
const { DEFAULT_PROMPTS } = require('../utils/constants');

/**
 * X·ª≠ l√Ω n√∫t "T·∫°o ph·ª• ƒë·ªÅ m·ªõi"
 * @param {object} ctx - Context Telegraf
 */
async function handleCreateSubtitleAction(ctx) {
	try {
		// Ki·ªÉm tra quy·ªÅn ng∆∞·ªùi d√πng
		const hasPermission = await checkUserPermission(ctx);
		console.log({ hasPermission });
		if (!hasPermission) {
			await ctx.answerCbQuery(
				'B·∫°n ƒë√£ s·ª≠ d·ª•ng h·∫øt l∆∞·ª£t d√πng trong ng√†y h√¥m nay.'
			);
			await ctx.reply(
				'üîí B·∫°n ƒë√£ s·ª≠ d·ª•ng h·∫øt l∆∞·ª£t d√πng trong ng√†y h√¥m nay. Vui l√≤ng th·ª≠ l·∫°i v√†o ng√†y mai ho·∫∑c n√¢ng c·∫•p t√†i kho·∫£n.'
			);
			return;
		}

		await ctx.answerCbQuery();
		await ctx.reply(
			formatMessage(
				EMOJI.VIDEO,
				'Nh·∫≠p URL video ho·∫∑c g·ª≠i file',
				'Vui l√≤ng g·ª≠i m·ªôt trong c√°c lo·∫°i sau:\n- URL video tr·ª±c ti·∫øp\n- URL YouTube\n- URL stream m3u8\n- Magnet link\n- Torrent file (.torrent)\n- G·ª≠i file video\n- G·ª≠i file ph·ª• ƒë·ªÅ .srt'
			),
			{
				parse_mode: 'HTML',
				...Markup.inlineKeyboard([
					[Markup.button.callback('H·ªßy', 'cancel_subtitle')],
				]),
			}
		);

		// C·∫≠p nh·∫≠t tr·∫°ng th√°i ng∆∞·ªùi d√πng ƒëang ch·ªù nh·∫≠p URL ho·∫∑c g·ª≠i file
		const userId = ctx.from.id;
		updateUserState(userId, 'waiting_for_url_or_file');
	} catch (error) {
		// ... existing code ...
	}
}

/**
 * X·ª≠ l√Ω n√∫t "H·ªßy" qu√° tr√¨nh t·∫°o ph·ª• ƒë·ªÅ
 * @param {object} ctx - Context Telegraf
 */
async function handleCancelSubtitleAction(ctx) {
	await ctx.answerCbQuery();
	const userId = ctx.from.id;
	resetUserState(userId);

	await ctx.reply(
		formatMessage(EMOJI.ERROR, 'ƒê√£ h·ªßy', 'Qu√° tr√¨nh t·∫°o ph·ª• ƒë·ªÅ ƒë√£ b·ªã h·ªßy.'),
		{
			parse_mode: 'HTML',
			...Markup.inlineKeyboard([
				[Markup.button.callback('Quay l·∫°i menu ch√≠nh', 'start')],
			]),
		}
	);
}

/**
 * X·ª≠ l√Ω n√∫t "D√πng prompt m·∫∑c ƒë·ªãnh"
 * @param {object} ctx - Context Telegraf
 */
async function handleDefaultPromptAction(ctx) {
	await ctx.answerCbQuery();

	const userId = ctx.from.id;
	const userState = getUserState(userId);

	// S·ª≠ d·ª•ng prompt m·∫∑c ƒë·ªãnh
	const defaultPrompt =
		'D·ªãch ph·ª• ƒë·ªÅ sang ti·∫øng Vi·ªát, gi·ªØ nguy√™n nghƒ©a g·ªëc v√† s·ª≠ d·ª•ng ng√¥n ng·ªØ t·ª± nhi√™n';

	// N·∫øu ƒë√£ c√≥ l·ª±a ch·ªçn output tr∆∞·ªõc ƒë√≥ (t·ª´ handleOutputOption)
	if (userState.state === 'waiting_for_prompt' && userState.outputOption) {
		// Chuy·ªÉn sang x·ª≠ l√Ω ngay
		updateUserState(userId, 'processing', {
			prompt: defaultPrompt,
		});

		const option = userState.outputOption;

		// X·ª≠ l√Ω theo lo·∫°i file
		if (userState.srtPath) {
			await processSrtFile(ctx, userState.srtPath, defaultPrompt, option);
		} else if (userState.videoPath) {
			await processLocalVideo(ctx, userState.videoPath, defaultPrompt, option);
		} else {
			await processSubtitle(ctx, userState.videoUrl, defaultPrompt, option);
		}

		// ƒê·∫∑t l·∫°i tr·∫°ng th√°i
		resetUserState(userId);
		return;
	}

	// Ng∆∞·ª£c l·∫°i, h·ªèi l·ª±a ch·ªçn output
	if (
		userState.state === 'waiting_for_prompt' &&
		(userState.videoUrl || userState.videoPath || userState.srtPath)
	) {
		// C·∫≠p nh·∫≠t tr·∫°ng th√°i v√† hi·ªÉn th·ªã t√πy ch·ªçn output
		updateUserState(userId, 'waiting_for_output_option', {
			prompt: defaultPrompt,
		});

		await ctx.reply(
			formatMessage(
				EMOJI.OPTIONS,
				'Ch·ªçn ki·ªÉu xu·∫•t k·∫øt qu·∫£',
				'Vui l√≤ng ch·ªçn c√°ch b·∫°n mu·ªën nh·∫≠n k·∫øt qu·∫£:'
			),
			{
				parse_mode: 'HTML',
				...Markup.inlineKeyboard([
					[
						Markup.button.callback(
							'1. Xu·∫•t file ph·ª• ƒë·ªÅ (m·∫∑c ƒë·ªãnh)',
							'output_option_1'
						),
					],
					[
						Markup.button.callback(
							'2. Gh√©p ph·ª• ƒë·ªÅ g·ªëc v√†o video',
							'output_option_2'
						),
					],
					[
						Markup.button.callback(
							'3. Gh√©p ph·ª• ƒë·ªÅ ti·∫øng Vi·ªát v√†o video',
							'output_option_3'
						),
					],
					[Markup.button.callback('H·ªßy', 'cancel_subtitle')],
				]),
			}
		);
	} else {
		ctx.reply(
			formatMessage(EMOJI.ERROR, 'L·ªói', 'Vui l√≤ng b·∫Øt ƒë·∫ßu l·∫°i qu√° tr√¨nh.'),
			{ parse_mode: 'HTML' }
		);
	}
}

/**
 * X·ª≠ l√Ω c√°c t√πy ch·ªçn output
 * @param {object} ctx - Context Telegraf
 * @param {string} option - T√πy ch·ªçn output (DEFAULT, MUXED_ORIGINAL, MUXED_TRANSLATED)
 */
async function handleOutputOption(ctx, option) {
	await ctx.answerCbQuery();
	const userId = ctx.from.id;
	const userState = getUserState(userId);

	if (userState.state !== 'waiting_for_output_option') {
		return ctx.reply(
			formatMessage(EMOJI.ERROR, 'L·ªói', 'Vui l√≤ng b·∫Øt ƒë·∫ßu l·∫°i qu√° tr√¨nh.'),
			{ parse_mode: 'HTML' }
		);
	}

	// Ki·ªÉm tra quy·ªÅn truy c·∫≠p cho user default
	const isUserAdmin = await isAdmin(ctx);
	if (!isUserAdmin && option !== OPTIONS.DEFAULT) {
		return ctx.reply(
			formatMessage(
				EMOJI.ERROR,
				'Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p',
				'T√†i kho·∫£n th∆∞·ªùng ch·ªâ ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng t√πy ch·ªçn m·∫∑c ƒë·ªãnh (Xu·∫•t file ph·ª• ƒë·ªÅ).'
			),
			{ parse_mode: 'HTML' }
		);
	}

	// N·∫øu ch·ªçn gh√©p ph·ª• ƒë·ªÅ ti·∫øng Vi·ªát v√†o video, y√™u c·∫ßu prompt
	if (option === OPTIONS.MUXED_TRANSLATED) {
		updateUserState(userId, 'waiting_for_prompt', {
			videoUrl: userState.videoUrl,
			videoPath: userState.videoPath,
			srtPath: userState.srtPath,
			outputOption: option,
		});

		return await ctx.reply(
			formatMessage(
				EMOJI.TRANSLATE,
				'Nh·∫≠p prompt d·ªãch',
				'Vui l√≤ng nh·∫≠p n·ªôi dung h∆∞·ªõng d·∫´n c√°ch d·ªãch ph·ª• ƒë·ªÅ (v√≠ d·ª•: "D·ªãch sang ti·∫øng Vi·ªát, gi·ªØ nguy√™n nghƒ©a g·ªëc").'
			),
			{
				parse_mode: 'HTML',
				...Markup.inlineKeyboard([
					[Markup.button.callback('D√πng prompt m·∫∑c ƒë·ªãnh', 'default_prompt')],
					[Markup.button.callback('D√πng prompt 18+', 'use_prompt_adult')],
					[Markup.button.callback('D√πng prompt phim', 'use_prompt_movie')],
					[Markup.button.callback('D√πng prompt anime', 'use_prompt_anime')],
					[
						Markup.button.callback(
							'D√πng prompt h·ªôi tho·∫°i',
							'use_prompt_conversation'
						),
					],
					[Markup.button.callback('H·ªßy', 'cancel_subtitle')],
				]),
			}
		);
	}

	// N·∫øu l√† c√°c l·ª±a ch·ªçn kh√°c, s·ª≠ d·ª•ng prompt m·∫∑c ƒë·ªãnh ho·∫∑c null
	const defaultPrompt =
		option === OPTIONS.DEFAULT
			? null
			: 'D·ªãch ph·ª• ƒë·ªÅ sang ti·∫øng Vi·ªát, gi·ªØ nguy√™n nghƒ©a g·ªëc v√† s·ª≠ d·ª•ng ng√¥n ng·ªØ t·ª± nhi√™n';

	updateUserState(userId, 'processing', {
		outputOption: option,
		prompt: userState.prompt || defaultPrompt,
	});

	// X·ª≠ l√Ω theo lo·∫°i file
	if (userState.srtPath) {
		// N·∫øu l√† file SRT, ch·ªâ c·∫ßn d·ªãch kh√¥ng c·∫ßn tr√≠ch xu·∫•t
		await processSrtFile(
			ctx,
			userState.srtPath,
			userState.prompt || defaultPrompt,
			option
		);
	} else if (userState.videoPath) {
		// N·∫øu l√† file video ƒë√£ t·∫£i l√™n
		await processLocalVideo(
			ctx,
			userState.videoPath,
			userState.prompt || defaultPrompt,
			option
		);
	} else {
		// N·∫øu l√† URL video
		await processSubtitle(
			ctx,
			userState.videoUrl,
			userState.prompt || defaultPrompt,
			option
		);
	}

	// ƒê·∫∑t l·∫°i tr·∫°ng th√°i
	resetUserState(userId);

	// N·∫øu x·ª≠ l√Ω th√†nh c√¥ng, tƒÉng s·ªë l·ªánh ƒë√£ d√πng
	await incrementUserCommand(ctx);
}

/**
 * X·ª≠ l√Ω action t·∫°o ph·ª• ƒë·ªÅ m·ªõi
 * @param {object} ctx - Context Telegraf
 */
const handleCreateSubtitleActionNew = async (ctx) => {
	try {
		await ctx.answerCbQuery();

		const userId = ctx.from.id.toString();
		resetUserState(userId); // Reset tr·∫°ng th√°i ng∆∞·ªùi d√πng

		// C·∫≠p nh·∫≠t tr·∫°ng th√°i ng∆∞·ªùi d√πng
		updateUserState(userId, 'waiting_for_url');

		await ctx.editMessageText(
			formatMessage(
				EMOJI.URL,
				'T·∫°o ph·ª• ƒë·ªÅ m·ªõi',
				'Vui l√≤ng g·ª≠i URL video ho·∫∑c t·∫£i l√™n file video tr·ª±c ti·∫øp.\n\nBot h·ªó tr·ª£:\n‚Ä¢ URL video tr·ª±c ti·∫øp (.mp4, .webm, ...)\n‚Ä¢ YouTube (youtube.com, youtu.be)\n‚Ä¢ Stream HLS (m3u8)\n‚Ä¢ Magnet link (magnet:...)\n‚Ä¢ Torrent file (.torrent)'
			),
			{
				parse_mode: 'HTML',
				...Markup.inlineKeyboard([
					[Markup.button.callback('H·ªßy', 'cancel_subtitle')],
				]),
			}
		);
	} catch (error) {
		console.error('Error in handleCreateSubtitleAction:', error);
	}
};

/**
 * X·ª≠ l√Ω action h·ªßy qu√° tr√¨nh t·∫°o ph·ª• ƒë·ªÅ
 * @param {object} ctx - Context Telegraf
 */
const handleCancelSubtitleActionNew = async (ctx) => {
	try {
		await ctx.answerCbQuery();

		const userId = ctx.from.id.toString();
		resetUserState(userId); // Reset tr·∫°ng th√°i ng∆∞·ªùi d√πng

		await ctx.editMessageText(
			formatMessage(EMOJI.CANCEL, 'ƒê√£ h·ªßy', 'Qu√° tr√¨nh t·∫°o ph·ª• ƒë·ªÅ ƒë√£ b·ªã h·ªßy.'),
			{
				parse_mode: 'HTML',
				...Markup.inlineKeyboard([
					[Markup.button.callback('Quay l·∫°i menu ch√≠nh', 'start')],
				]),
			}
		);
	} catch (error) {
		console.error('Error in handleCancelSubtitleAction:', error);
	}
};

/**
 * X·ª≠ l√Ω action ch·ªçn prompt m·∫∑c ƒë·ªãnh
 * @param {object} ctx - Context Telegraf
 */
const handleDefaultPromptActionNew = async (ctx) => {
	try {
		await ctx.answerCbQuery();

		const userId = ctx.from.id.toString();
		const userState = getUserState(userId);

		if (!userState) {
			// N·∫øu kh√¥ng c√≥ tr·∫°ng th√°i ng∆∞·ªùi d√πng, quay v·ªÅ m√†n h√¨nh ch√≠nh
			await ctx.editMessageText(
				formatMessage(
					EMOJI.ERROR,
					'L·ªói',
					'Phi√™n l√†m vi·ªác c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n. Vui l√≤ng b·∫Øt ƒë·∫ßu l·∫°i.'
				),
				{
					parse_mode: 'HTML',
					...Markup.inlineKeyboard([
						[Markup.button.callback('Quay l·∫°i menu ch√≠nh', 'start')],
					]),
				}
			);
			return;
		}

		// Hi·ªÉn th·ªã danh s√°ch prompt m·∫∑c ƒë·ªãnh
		await ctx.editMessageText(
			formatMessage(
				EMOJI.PROMPT,
				'Ch·ªçn prompt m·∫∑c ƒë·ªãnh',
				'Vui l√≤ng ch·ªçn m·ªôt trong c√°c prompt m·∫´u d∆∞·ªõi ƒë√¢y ho·∫∑c t·ª± nh·∫≠p prompt c·ªßa ri√™ng b·∫°n:'
			),
			{
				parse_mode: 'HTML',
				...Markup.inlineKeyboard([
					[
						Markup.button.callback(
							'T·ª± ƒë·ªông ph√°t hi·ªán ng√¥n ng·ªØ',
							'auto_detect_language'
						),
					],
					[Markup.button.callback('D·ªãch th√¥ng th∆∞·ªùng', 'use_prompt_normal')],
					[Markup.button.callback('D·ªãch phim/ph·ª• ƒë·ªÅ', 'use_prompt_movie')],
					[Markup.button.callback('D·ªãch anime/manga', 'use_prompt_anime')],
					[
						Markup.button.callback(
							'D·ªãch h·ªôi tho·∫°i t·ª± nhi√™n',
							'use_prompt_conversation'
						),
					],
					[Markup.button.callback('D·ªãch ph·ª• ƒë·ªÅ 18+', 'use_prompt_adult')],
					[Markup.button.callback('T·ª± nh·∫≠p prompt', 'custom_prompt')],
					[Markup.button.callback('H·ªßy', 'cancel_subtitle')],
				]),
			}
		);
	} catch (error) {
		console.error('Error in handleDefaultPromptAction:', error);
	}
};

/**
 * X·ª≠ l√Ω action ch·ªçn t√πy ch·ªçn xu·∫•t k·∫øt qu·∫£ 1 (xu·∫•t file ph·ª• ƒë·ªÅ)
 * @param {object} ctx - Context Telegraf
 */
const handleOutputOption1Action = async (ctx) => {
	await handleOutputOption(ctx, OPTIONS.DEFAULT);
};

/**
 * X·ª≠ l√Ω action ch·ªçn t√πy ch·ªçn xu·∫•t k·∫øt qu·∫£ 2 (gh√©p ph·ª• ƒë·ªÅ g·ªëc v√†o video)
 * @param {object} ctx - Context Telegraf
 */
const handleOutputOption2Action = async (ctx) => {
	await handleOutputOption(ctx, OPTIONS.MUXED_ORIGINAL);
};

/**
 * X·ª≠ l√Ω action ch·ªçn t√πy ch·ªçn xu·∫•t k·∫øt qu·∫£ 3 (gh√©p ph·ª• ƒë·ªÅ ti·∫øng Vi·ªát v√†o video)
 * @param {object} ctx - Context Telegraf
 */
const handleOutputOption3Action = async (ctx) => {
	await handleOutputOption(ctx, OPTIONS.MUXED_TRANSLATED);
};

/**
 * X·ª≠ l√Ω action ch·ªçn t√πy ch·ªçn xu·∫•t k·∫øt qu·∫£
 * @param {object} ctx - Context Telegraf
 * @param {number} option - T√πy ch·ªçn xu·∫•t k·∫øt qu·∫£ (OPTIONS.DEFAULT, OPTIONS.MUXED_ORIGINAL, OPTIONS.MUXED_TRANSLATED)
 */
async function handleOutputOptionNew(ctx, option) {
	try {
		await ctx.answerCbQuery();

		const userId = ctx.from.id.toString();
		const userState = getUserState(userId);

		if (!userState) {
			// N·∫øu kh√¥ng c√≥ tr·∫°ng th√°i ng∆∞·ªùi d√πng, quay v·ªÅ m√†n h√¨nh ch√≠nh
			await ctx.editMessageText(
				formatMessage(
					EMOJI.ERROR,
					'L·ªói',
					'Phi√™n l√†m vi·ªác c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n. Vui l√≤ng b·∫Øt ƒë·∫ßu l·∫°i.'
				),
				{
					parse_mode: 'HTML',
					...Markup.inlineKeyboard([
						[Markup.button.callback('Quay l·∫°i menu ch√≠nh', 'start')],
					]),
				}
			);
			return;
		}

		// C·∫≠p nh·∫≠t l·ª±a ch·ªçn xu·∫•t k·∫øt qu·∫£
		updateUserState(userId, userState.state, {
			...userState,
			outputOption: option,
		});

		// N·∫øu ƒë√£ c√≥ prompt, ti·∫øn h√†nh x·ª≠ l√Ω
		if (userState.prompt) {
			await handleProcess(ctx, userId, option);
			return;
		}

		// N·∫øu ch∆∞a c√≥ prompt, y√™u c·∫ßu nh·∫≠p prompt
		await ctx.editMessageText(
			formatMessage(
				EMOJI.PROMPT,
				'Nh·∫≠p prompt d·ªãch thu·∫≠t',
				'Vui l√≤ng nh·∫≠p prompt m√¥ t·∫£ c√°ch b·∫°n mu·ªën d·ªãch ph·ª• ƒë·ªÅ sang ti·∫øng Vi·ªát.\nV√≠ d·ª•: "D·ªãch ph·ª• ƒë·ªÅ n√†y sang ti·∫øng Vi·ªát, gi·ªØ nguy√™n √Ω nghƒ©a g·ªëc"'
			),
			{
				parse_mode: 'HTML',
				...Markup.inlineKeyboard([
					[Markup.button.callback('Ch·ªçn prompt m·∫´u', 'default_prompt')],
					[Markup.button.callback('D√πng prompt phim', 'use_prompt_movie')],
					[Markup.button.callback('D√πng prompt anime', 'use_prompt_anime')],
					[
						Markup.button.callback(
							'D·ªãch h·ªôi tho·∫°i t·ª± nhi√™n',
							'use_prompt_conversation'
						),
					],
					[Markup.button.callback('D√πng prompt 18+', 'use_prompt_adult')],
					[Markup.button.callback('T·ª± nh·∫≠p prompt', 'custom_prompt')],
					[Markup.button.callback('H·ªßy', 'cancel_subtitle')],
				]),
			}
		);

		// C·∫≠p nh·∫≠t tr·∫°ng th√°i ng∆∞·ªùi d√πng
		updateUserState(userId, 'waiting_for_prompt');
	} catch (error) {
		console.error('Error in handleOutputOption:', error);
	}
}

/**
 * X·ª≠ l√Ω ch·ªçn prompt m·∫´u
 */
const handleUsePromptAction = async (ctx, promptType) => {
	try {
		await ctx.answerCbQuery();

		const userId = ctx.from.id.toString();
		const userState = getUserState(userId);

		if (!userState) {
			// N·∫øu kh√¥ng c√≥ tr·∫°ng th√°i ng∆∞·ªùi d√πng, quay v·ªÅ m√†n h√¨nh ch√≠nh
			await ctx.editMessageText(
				formatMessage(
					EMOJI.ERROR,
					'L·ªói',
					'Phi√™n l√†m vi·ªác c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n. Vui l√≤ng b·∫Øt ƒë·∫ßu l·∫°i.'
				),
				{
					parse_mode: 'HTML',
					...Markup.inlineKeyboard([
						[Markup.button.callback('Quay l·∫°i menu ch√≠nh', 'start')],
					]),
				}
			);
			return;
		}

		let prompt = DEFAULT_PROMPTS.normal;
		switch (promptType) {
			case 'normal':
				prompt = DEFAULT_PROMPTS.normal;
				break;
			case 'movie':
				prompt = DEFAULT_PROMPTS.movie;
				break;
			case 'anime':
				prompt = DEFAULT_PROMPTS.anime;
				break;
			case 'conversation':
				prompt = DEFAULT_PROMPTS.conversation;
				break;
			case 'adult':
				prompt = DEFAULT_PROMPTS.adult;
				break;
			case 'auto':
				// S·∫Ω chuy·ªÉn sang t·ª± ƒë·ªông ph√°t hi·ªán ng√¥n ng·ªØ
				prompt = '';
				break;
			default:
				prompt = DEFAULT_PROMPTS.normal;
		}

		// C·∫≠p nh·∫≠t prompt
		updateUserState(userId, 'processing', {
			...userState,
			prompt,
		});

		// Hi·ªÉn th·ªã th√¥ng b√°o ch·ªù x·ª≠ l√Ω
		await ctx.editMessageText(
			formatMessage(
				promptType === 'auto' ? EMOJI.LOADING : EMOJI.PROMPT,
				promptType === 'auto'
					? 'ƒêang t·ª± ƒë·ªông ph√°t hi·ªán ng√¥n ng·ªØ'
					: 'ƒê√£ ch·ªçn prompt',
				promptType === 'auto'
					? 'H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông ph√°t hi·ªán ng√¥n ng·ªØ c·ªßa video v√† ƒë·ªÅ xu·∫•t prompt ph√π h·ª£p.\nƒêang b·∫Øt ƒë·∫ßu x·ª≠ l√Ω, vui l√≤ng ƒë·ª£i trong gi√¢y l√°t...'
					: `ƒê√£ ch·ªçn prompt: "${prompt}"\nƒêang b·∫Øt ƒë·∫ßu x·ª≠ l√Ω, vui l√≤ng ƒë·ª£i trong gi√¢y l√°t...`
			),
			{
				parse_mode: 'HTML',
			}
		);

		// Ti·∫øn h√†nh x·ª≠ l√Ω
		await handleProcess(ctx, userId, userState.outputOption);
	} catch (error) {
		console.error('Error in handleUsePromptAction:', error);
	}
};

/**
 * X·ª≠ l√Ω khi ng∆∞·ªùi d√πng ch·ªçn t·ª± nh·∫≠p prompt
 */
const handleCustomPromptAction = async (ctx) => {
	try {
		await ctx.answerCbQuery();

		const userId = ctx.from.id.toString();
		const userState = getUserState(userId);

		if (!userState) {
			// N·∫øu kh√¥ng c√≥ tr·∫°ng th√°i ng∆∞·ªùi d√πng, quay v·ªÅ m√†n h√¨nh ch√≠nh
			await ctx.editMessageText(
				formatMessage(
					EMOJI.ERROR,
					'L·ªói',
					'Phi√™n l√†m vi·ªác c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n. Vui l√≤ng b·∫Øt ƒë·∫ßu l·∫°i.'
				),
				{
					parse_mode: 'HTML',
					...Markup.inlineKeyboard([
						[Markup.button.callback('Quay l·∫°i menu ch√≠nh', 'start')],
					]),
				}
			);
			return;
		}

		// Y√™u c·∫ßu ng∆∞·ªùi d√πng nh·∫≠p prompt
		await ctx.editMessageText(
			formatMessage(
				EMOJI.PROMPT,
				'Nh·∫≠p prompt d·ªãch thu·∫≠t',
				'Vui l√≤ng nh·∫≠p prompt m√¥ t·∫£ c√°ch b·∫°n mu·ªën d·ªãch ph·ª• ƒë·ªÅ sang ti·∫øng Vi·ªát.\nV√≠ d·ª•: "D·ªãch ph·ª• ƒë·ªÅ n√†y sang ti·∫øng Vi·ªát, gi·ªØ nguy√™n √Ω nghƒ©a g·ªëc"'
			),
			{
				parse_mode: 'HTML',
				...Markup.inlineKeyboard([
					[Markup.button.callback('Quay l·∫°i', 'default_prompt')],
					[Markup.button.callback('D√πng prompt phim', 'use_prompt_movie')],
					[Markup.button.callback('D√πng prompt anime', 'use_prompt_anime')],
					[
						Markup.button.callback(
							'D·ªãch h·ªôi tho·∫°i t·ª± nhi√™n',
							'use_prompt_conversation'
						),
					],
					[Markup.button.callback('D√πng prompt 18+', 'use_prompt_adult')],
					[Markup.button.callback('H·ªßy', 'cancel_subtitle')],
				]),
			}
		);

		// C·∫≠p nh·∫≠t tr·∫°ng th√°i ng∆∞·ªùi d√πng
		updateUserState(userId, 'waiting_for_prompt');
	} catch (error) {
		console.error('Error in handleCustomPromptAction:', error);
	}
};

/**
 * X·ª≠ l√Ω qu√° tr√¨nh t·∫°o ph·ª• ƒë·ªÅ
 * @param {object} ctx - Context Telegraf
 * @param {string} userId - ID c·ªßa ng∆∞·ªùi d√πng
 * @param {number} option - T√πy ch·ªçn xu·∫•t k·∫øt qu·∫£
 */
async function handleProcess(ctx, userId, option) {
	try {
		const userState = getUserState(userId);

		if (!userState) {
			return;
		}

		// ƒê√°nh d·∫•u ƒëang x·ª≠ l√Ω
		updateUserState(userId, 'processing');

		// Ti·∫øn h√†nh x·ª≠ l√Ω d·ª±a tr√™n lo·∫°i video
		if (userState.srtPath) {
			// N·∫øu l√† file SRT
			await processSrtFile(ctx, userState.srtPath, userState.prompt, option);
		} else if (userState.videoPath) {
			// N·∫øu l√† video ƒë∆∞·ª£c t·∫£i l√™n
			await processLocalVideo(
				ctx,
				userState.videoPath,
				userState.prompt,
				option
			);
		} else if (userState.videoUrl) {
			// N·∫øu l√† URL video
			await processSubtitle(ctx, userState.videoUrl, userState.prompt, option);
		} else {
			// N·∫øu kh√¥ng c√≥ th√¥ng tin video
			await ctx.reply(
				formatMessage(
					EMOJI.ERROR,
					'L·ªói',
					'Kh√¥ng c√≥ th√¥ng tin video ƒë∆∞·ª£c cung c·∫•p. Vui l√≤ng th·ª≠ l·∫°i.'
				),
				{
					parse_mode: 'HTML',
					...Markup.inlineKeyboard([
						[Markup.button.callback('T·∫°o ph·ª• ƒë·ªÅ m·ªõi', 'create_subtitle')],
						[Markup.button.callback('Quay l·∫°i menu ch√≠nh', 'start')],
					]),
				}
			);
		}

		// Reset tr·∫°ng th√°i ng∆∞·ªùi d√πng sau khi ho√†n t·∫•t
		resetUserState(userId);
	} catch (error) {
		console.error('Error in handleProcess:', error);
	}
}

// Xu·∫•t c√°c h√†m x·ª≠ l√Ω action
module.exports = {
	handleCreateSubtitleAction,
	handleCancelSubtitleAction,
	handleDefaultPromptAction,
	handleOutputOption1Action,
	handleOutputOption2Action,
	handleOutputOption3Action,
	handleUsePromptNormal: (ctx) => handleUsePromptAction(ctx, 'normal'),
	handleUsePromptMovie: (ctx) => handleUsePromptAction(ctx, 'movie'),
	handleUsePromptAnime: (ctx) => handleUsePromptAction(ctx, 'anime'),
	handleUsePromptConversation: (ctx) =>
		handleUsePromptAction(ctx, 'conversation'),
	handleUsePromptAdult: (ctx) => handleUsePromptAction(ctx, 'adult'),
	handleUseAutoDetectLanguage: (ctx) => handleUsePromptAction(ctx, 'auto'),
	handleCustomPromptAction,
};
